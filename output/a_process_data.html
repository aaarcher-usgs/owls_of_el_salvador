<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Processing data from Access</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Processing data from Access</h1>

<p>Description: This program takes raw data exported 
from Access database and organizes it to better understand what data are 
available and process it for analysis.</p>

<h3>Preamble</h3>

<p>Load libraries</p>

<pre><code class="r">library(knitr) # documentation-related
library(ezknitr) # documentation-related
library(devtools) # documentation-related

# analysis-related
library(readxl)
library(lubridate)
library(dplyr)
library(ImportExport)
</code></pre>

<p>Clear environment and set seed</p>

<p><em>Note: for reproducibility, it is important to include these. Clearing the
environment ensures that you have specified all pertinent files that need
to be loaded, and setting the seed ensures that your analysis is 
repeatable</em></p>

<pre><code class="r">remove(list = ls())
set.seed(2583722)
</code></pre>

<hr/>

<h2>Load Data</h2>

<h3>Route Table</h3>

<p>Routes are the six unique transects or routes with two per protected area (Forest).
There are unique IDs that correspond with protected area, and six unique route
names, as well.</p>

<pre><code class="r">tab.route &lt;- read_xlsx(path = &quot;data/raw_data/Route_Table.xlsx&quot;,
                       sheet = &quot;Route_Table&quot;)
tab.route
</code></pre>

<pre><code>## # A tibble: 6 x 4
##   Route_ID Route_Name            Forest       Coordinates
##   &lt;chr&gt;    &lt;chr&gt;                 &lt;chr&gt;        &lt;lgl&gt;      
## 1 EI1      Lomo de Paja          El Imposible NA         
## 2 EI2      La Cascada            El Imposible NA         
## 3 M1       Bosque Nebuloso       Montecristo  NA         
## 4 M2       Bosque Pinos y Robles Montecristo  NA         
## 5 N1       Borda                 Nancuchiname NA         
## 6 N2       Sector 2              Nancuchiname NA
</code></pre>

<h3>Stations Table</h3>

<p>Each route consists of 10 stations. There is no table with information about 
the 60 total stations. Instead, this stations table has each station repeated 
for each survey night with unique measurements of temperature, barometer, 
broadcast species, and background noise level (from 0 to 3). The
link between these stations and the actual individual surveys is the field &ldquo;Survey_ID&rdquo;.</p>

<pre><code class="r">tab.stations &lt;- read_xlsx(path = &quot;data/raw_data/Stations_Table.xlsx&quot;,
                          sheet = &quot;Stations_Table&quot;)
dim(tab.stations)
</code></pre>

<pre><code>## [1] 859  11
</code></pre>

<pre><code class="r">head(tab.stations)
</code></pre>

<pre><code>## # A tibble: 6 x 11
##   Stations_ID Survey_ID Station Station_Start_Time  Temperature Barometer   Fog Wind_Speed
##         &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;   &lt;dttm&gt;                    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1          12        11 EI1.1   1899-12-31 18:30:00          28      34.9     0          0
## 2          13        11 EI1.2   1899-12-31 18:58:00          27      34.9     0          0
## 3          14        11 EI1.3   1899-12-31 19:16:00          27      34.9     0          0
## 4          15        11 EI1.4   1899-12-31 19:36:00          27      35.0     0          0
## 5          16        11 EI1.5   1899-12-31 19:55:00          26      35.0     0          0
## 6          17        11 EI1.6   1899-12-31 20:18:00          27      34.8     0          0
## # … with 3 more variables: Broadcast_Species &lt;chr&gt;, Background_Noise &lt;dbl&gt;,
## #   Station_Comments &lt;chr&gt;
</code></pre>

<pre><code class="r">unique(tab.stations$Station)
</code></pre>

<pre><code>##  [1] &quot;EI1.1&quot;  &quot;EI1.2&quot;  &quot;EI1.3&quot;  &quot;EI1.4&quot;  &quot;EI1.5&quot;  &quot;EI1.6&quot;  &quot;EI1.7&quot;  &quot;EI1.8&quot;  &quot;EI1.9&quot;  &quot;EI1.10&quot;
## [11] &quot;EI2.1&quot;  &quot;EI2.2&quot;  &quot;EI2.3&quot;  &quot;EI2.4&quot;  &quot;EI2.5&quot;  &quot;EI2.6&quot;  &quot;EI2.7&quot;  &quot;EI2.8&quot;  &quot;EI2.9&quot;  &quot;EI2.10&quot;
## [21] &quot;N1.1&quot;   &quot;N1.2&quot;   &quot;N1.3&quot;   &quot;N1.4&quot;   &quot;N1.5&quot;   &quot;N1.6&quot;   &quot;N1.7&quot;   &quot;N1.8&quot;   &quot;N1.9&quot;   &quot;N1.10&quot; 
## [31] &quot;N2.1&quot;   &quot;N2.2&quot;   &quot;N2.3&quot;   &quot;N2.4&quot;   &quot;N2.5&quot;   &quot;N2.6&quot;   &quot;N2.7&quot;   &quot;N2.8&quot;   &quot;N2.9&quot;   &quot;N2.10&quot; 
## [41] &quot;M1.1&quot;   &quot;M1.2&quot;   &quot;M1.3&quot;   &quot;M1.4&quot;   &quot;M1.5&quot;   &quot;M1.6&quot;   &quot;M1.7&quot;   &quot;M1.8&quot;   &quot;M1.9&quot;   &quot;M1.10&quot; 
## [51] &quot;M2.1&quot;   &quot;M2.2&quot;   &quot;M2.3&quot;   &quot;M2.4&quot;   &quot;M2.5&quot;   &quot;M2.6&quot;   &quot;M2.7&quot;   &quot;M2.8&quot;   &quot;M2.9&quot;   &quot;M2.10&quot;
</code></pre>

<pre><code class="r">length(unique(tab.stations$Station))
</code></pre>

<pre><code>## [1] 60
</code></pre>

<p>The Station_Start_Time did not read in correctly because in Excel it is assuming 
the origin date of 1899-12-31. The correct date will come from the Survey Table, below.</p>

<pre><code class="r">head(tab.stations$Station_Start_Time)
</code></pre>

<pre><code>## [1] &quot;1899-12-31 18:30:00 UTC&quot; &quot;1899-12-31 18:58:00 UTC&quot; &quot;1899-12-31 19:16:00 UTC&quot;
## [4] &quot;1899-12-31 19:36:00 UTC&quot; &quot;1899-12-31 19:55:00 UTC&quot; &quot;1899-12-31 20:18:00 UTC&quot;
</code></pre>

<h3>Survey Table</h3>

<p>This includes 2002 surveys that have to be deleted from analysis.</p>

<pre><code class="r">tab.survey &lt;- read_xlsx(path = &quot;data/raw_data/Survey_Table.xlsx&quot;,
                       sheet = &quot;Survey_Table&quot;)
table(tab.survey$Route_ID)
</code></pre>

<pre><code>## 
## EI1 EI2  M1  M2  N1  N2 
##  17  14   7  12  20  20
</code></pre>

<p>Remove data for year = 2002</p>

<pre><code class="r">tab.survey$year &lt;- lubridate::year(tab.survey$Survey_Date)
table(tab.survey$year)
</code></pre>

<pre><code>## 
## 2002 2003 2004 2005 2007 2008 2009 2010 2011 2012 2013 
##    6    8    9   11    9   10    7    8   10    8    4
</code></pre>

<pre><code class="r">(survey_id_2002 &lt;- tab.survey$Survey_ID[tab.survey$year==2002])
</code></pre>

<pre><code>## [1] 28 29 30 31 32 33
</code></pre>

<pre><code class="r">tab.survey &lt;- tab.survey[tab.survey$year &gt;= 2003,]
table(tab.survey$year)
</code></pre>

<pre><code>## 
## 2003 2004 2005 2007 2008 2009 2010 2011 2012 2013 
##    8    9   11    9   10    7    8   10    8    4
</code></pre>

<p>Also remove 2002 surveys from stations data</p>

<pre><code class="r">table(tab.stations$Survey_ID)
</code></pre>

<pre><code>## 
##  11  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 
##  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10   3  10   2   3 
##  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59 
##  10  10  10  10  10  10  10  10  10  10  10  10   5  10  10  10  10  10  10  10  10  10  10  10 
##  60  61  62  63  64  65  66  67  68  69  71  72  73  74  75  76  77  78  79  80  81  82  83  84 
##  10  10  10  10  10  10  10  10  10  10  10  10   3   3  10  10  10  10  10  10  10  10  10  10 
##  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 
##  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10
</code></pre>

<pre><code class="r">(station_id_2002 &lt;- tab.stations$Stations_ID[tab.stations$Survey_ID %in% survey_id_2002])
</code></pre>

<pre><code>##  [1] 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199
## [24] 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 218 219 220 228 229 230
## [47] 231 232 233 234 235 236 237
</code></pre>

<pre><code class="r">tab.stations &lt;- tab.stations[!tab.stations$Survey_ID %in% survey_id_2002,]
table(tab.stations$Survey_ID)
</code></pre>

<pre><code>## 
##  11  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  34  35  36  37  38  39  40  41 
##  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10   2   3  10  10  10  10  10  10 
##  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65 
##  10  10  10  10  10  10   5  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10 
##  66  67  68  69  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 
##  10  10  10  10  10  10   3   3  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10  10 
##  91  92  93  94  95  96  97  98  99 100 101 102 
##  10  10  10  10  10  10  10  10  10  10  10  10
</code></pre>

<h3>Owls Table</h3>

<p>This table has all observed owls.</p>

<pre><code class="r">tab.owls &lt;- read_xlsx(path = &quot;data/raw_data/Owls_Table.xlsx&quot;,
                      sheet = &quot;Owls_Table&quot;)
# Dimensions of owls table (rows, columns)
dim(tab.owls)
</code></pre>

<pre><code>## [1] 939  10
</code></pre>

<pre><code class="r"># Head of owls table
head(tab.owls)
</code></pre>

<pre><code>## # A tibble: 6 x 10
##   Owl_ID Stations_ID Owl_Species_ID Owl_Number Minute_1 Minute_2 `Minute_6-12` Owl_Distance
##    &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;      &lt;lgl&gt;    &lt;lgl&gt;    &lt;lgl&gt;                &lt;dbl&gt;
## 1     17          12 Mottd          1          TRUE     TRUE     TRUE                   400
## 2     18          12 Mottd          2          FALSE    FALSE    TRUE                   300
## 3     19          13 PacSc          1          FALSE    TRUE     TRUE                    20
## 4     20          13 Mottd          2          FALSE    FALSE    TRUE                   200
## 5     21          13 Mottd          3          FALSE    FALSE    TRUE                   200
## 6     22          14 Mottd          1          TRUE     TRUE     FALSE                  400
## # … with 2 more variables: Owl_Direction &lt;chr&gt;, Owl_Comments &lt;chr&gt;
</code></pre>

<p>Remove data for year = 2002 from owls table</p>

<pre><code class="r">tab.owls &lt;- tab.owls[! tab.owls$Stations_ID %in% station_id_2002,]
dim(tab.owls)
</code></pre>

<pre><code>## [1] 921  10
</code></pre>

<p>Owl Number is character, but should be numerical</p>

<pre><code class="r"># Is it a character because it has any letter values? 
table(tab.owls$Owl_Number)
</code></pre>

<pre><code>## 
##   1   2   3   4   5   6   7   8   9 
## 468 248 120  59  19   4   1   1   1
</code></pre>

<pre><code class="r"># No.... In that case, convert to numeric
tab.owls$Owl_Number &lt;- as.numeric(tab.owls$Owl_Number)
summary(tab.owls$Owl_Number)
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.000   1.000   1.000   1.849   2.000   9.000
</code></pre>

<p>How many of each species of owl are there?</p>

<pre><code class="r">table(tab.owls$Owl_Species_ID)
</code></pre>

<pre><code>## 
##    Barn   FerPy Fulvous   GrHor   Mottd    NoID    None   PacSc   Specd    Styg   Whisk 
##      10     184      17       3     530       2       8      27     137       1       2
</code></pre>

<p>Make &ldquo;None&rdquo; and &ldquo;NoID&rdquo; match</p>

<pre><code class="r">tab.owls$Owl_Species_ID &lt;- ifelse(test = tab.owls$Owl_Species_ID == &quot;None&quot; |
                                    tab.owls$Owl_Species_ID == &quot;NoID&quot;,
                                  yes = &quot;Unk&quot;,
                                  no = tab.owls$Owl_Species_ID)
table(tab.owls$Owl_Species_ID)
</code></pre>

<pre><code>## 
##    Barn   FerPy Fulvous   GrHor   Mottd   PacSc   Specd    Styg     Unk   Whisk 
##      10     184      17       3     530      27     137       1      10       2
</code></pre>

<hr/>

<h2>Prepare for JAGS</h2>

<p>For surveys that happened multiple times per year, determine the order of
those surveys with new variable &ldquo;order&rdquo;</p>

<pre><code class="r"># Create a unique identifier for each route per year
tab.survey$hRt_tYr &lt;- paste(tab.survey$Route_ID, tab.survey$year, sep = &quot;.&quot;)
route.year &lt;- sort(unique(tab.survey$hRt_tYr))

# Create new blank column and then populate based on the order of surveys per
# route and year.
tab.survey$order &lt;- NA
for(ht in 1:length(route.year)){
  order.dates.per.survey.per.yr &lt;- 
    order(tab.survey$Survey_Date[tab.survey$hRt_tYr == route.year[ht]])
  tab.survey$order[tab.survey$hRt_tYr == route.year[ht]] &lt;- order.dates.per.survey.per.yr
}
</code></pre>

<p>Concatenate that order index with route/year column to create unique identifier
for each different survey</p>

<pre><code class="r">tab.survey$hRt_tYr_iSvy &lt;- paste(tab.survey$hRt_tYr, tab.survey$order, sep = &quot;.&quot;)
head(tab.survey$hRt_tYr_iSvy)
</code></pre>

<pre><code>## [1] &quot;EI1.2004.1&quot; &quot;EI1.2004.2&quot; &quot;EI2.2004.1&quot; &quot;EI2.2004.2&quot; &quot;N1.2004.1&quot;  &quot;N1.2004.2&quot;
</code></pre>

<p>Create table of all conducted surveys by route and year</p>

<pre><code class="r">survey_list &lt;- sort(unique(tab.survey$hRt_tYr))
</code></pre>

<h3>Begin with survey data, order and clean</h3>

<p>Sort survey data by Route then survey date</p>

<pre><code class="r">data.jags &lt;- dplyr::arrange(tab.survey, Route_ID, Survey_Date)
</code></pre>

<p>Drop unneccessary columns</p>

<pre><code class="r">colnames(data.jags)
</code></pre>

<pre><code>##  [1] &quot;Survey_ID&quot;               &quot;Route_ID&quot;                &quot;Surveyor_ID&quot;            
##  [4] &quot;Surveyor_Assistant_ID_1&quot; &quot;Surveyor_Assistant_ID_2&quot; &quot;Survey_Date&quot;            
##  [7] &quot;Survey_Start_Time&quot;       &quot;Survey_Finish_Time&quot;      &quot;Cloud_Cover_Start&quot;      
## [10] &quot;Cloud_Cover_Finish&quot;      &quot;Precipitation&quot;           &quot;Moon_Phase&quot;             
## [13] &quot;Survey_Comments&quot;         &quot;year&quot;                    &quot;hRt_tYr&quot;                
## [16] &quot;order&quot;                   &quot;hRt_tYr_iSvy&quot;
</code></pre>

<pre><code class="r">temp.names.keep &lt;- c(&quot;Survey_ID&quot;, &quot;Route_ID&quot;, &quot;Survey_Date&quot;, 
                     &quot;year&quot;, &quot;hRt_tYr&quot;, &quot;order&quot;, &quot;hRt_tYr_iSvy&quot;)
data.jags &lt;- data.jags[,temp.names.keep]
head(data.jags)
</code></pre>

<pre><code>## # A tibble: 6 x 7
##   Survey_ID Route_ID Survey_Date          year hRt_tYr  order hRt_tYr_iSvy
##       &lt;dbl&gt; &lt;chr&gt;    &lt;dttm&gt;              &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;       
## 1        20 EI1      2003-04-27 00:00:00  2003 EI1.2003     1 EI1.2003.1  
## 2        21 EI1      2003-04-30 00:00:00  2003 EI1.2003     2 EI1.2003.2  
## 3        11 EI1      2004-03-28 00:00:00  2004 EI1.2004     1 EI1.2004.1  
## 4        13 EI1      2004-03-30 00:00:00  2004 EI1.2004     2 EI1.2004.2  
## 5        39 EI1      2005-03-29 00:00:00  2005 EI1.2005     1 EI1.2005.1  
## 6        41 EI1      2005-03-31 00:00:00  2005 EI1.2005     2 EI1.2005.2
</code></pre>

<p>Add year index</p>

<pre><code class="r">years.analysis &lt;- min(data.jags$year):max(data.jags$year)
data.jags$yearIndex &lt;- NA
for(tt in 1:length(years.analysis)){
  data.jags$yearIndex[data.jags$year == years.analysis[tt]] &lt;- tt
}

# Double check that year counts match
table(data.jags$year)
</code></pre>

<pre><code>## 
## 2003 2004 2005 2007 2008 2009 2010 2011 2012 2013 
##    8    9   11    9   10    7    8   10    8    4
</code></pre>

<pre><code class="r">table(data.jags$yearIndex)
</code></pre>

<pre><code>## 
##  1  2  3  5  6  7  8  9 10 11 
##  8  9 11  9 10  7  8 10  8  4
</code></pre>

<hr/>

<h2>Create tables for Ys and Broad Cast species covariates</h2>

<p>Create an array of Ys (detections/non-detections) for each of the <strong>possible</strong>
surveys</p>

<p>Specifically: 6 routes (hh), 10 stations (jj), up to 3 surveys per year (ii), 
11 total years (tt)
and 2 broadcast times (kk)</p>

<p>There will be 198 total matrices, each with 10 rows (j, stations) and 2 columns 
(k, before or after broadcast)</p>

<pre><code class="r"># Create blank lists
ys &lt;- list(NA)
ks &lt;- list(NA)

# How many total matrices should there be?
(total.num.hti &lt;- nrow(tab.route)* #6, number of routes h
  max(tab.survey$order)*    #3, max number of surveys i per year
  length(min(tab.survey$year):max(tab.survey$year))) #11, number of total years
</code></pre>

<pre><code>## [1] 198
</code></pre>

<pre><code class="r"># Create lists of blank matrices and name them appropriately
for(hti in 1:total.num.hti){
  ys[[hti]] &lt;- matrix(NA, ncol = 2, nrow = 10)
  ks[[hti]] &lt;- matrix(NA, ncol = 2, nrow = 10)
}
names(ys) &lt;- names(ks) &lt;- 
  paste(rep(tab.route$Route_ID, each = 33), 
        rep(rep(min(tab.survey$year):max(tab.survey$year), each = 3),6),
        rep(1:3, 66),
        sep=&quot;.&quot;)
names(ys)[1:20]
</code></pre>

<pre><code>##  [1] &quot;EI1.2003.1&quot; &quot;EI1.2003.2&quot; &quot;EI1.2003.3&quot; &quot;EI1.2004.1&quot; &quot;EI1.2004.2&quot; &quot;EI1.2004.3&quot; &quot;EI1.2005.1&quot;
##  [8] &quot;EI1.2005.2&quot; &quot;EI1.2005.3&quot; &quot;EI1.2006.1&quot; &quot;EI1.2006.2&quot; &quot;EI1.2006.3&quot; &quot;EI1.2007.1&quot; &quot;EI1.2007.2&quot;
## [15] &quot;EI1.2007.3&quot; &quot;EI1.2008.1&quot; &quot;EI1.2008.2&quot; &quot;EI1.2008.3&quot; &quot;EI1.2009.1&quot; &quot;EI1.2009.2&quot;
</code></pre>

<p>Process broadcast species data</p>

<p>Each station should always have the same broadcast species, which are listed
in &ldquo;tab.stations&rdquo;</p>

<pre><code class="r">stationIDs &lt;- unique(tab.stations$Station)
for(jj in 1:length(stationIDs)){
  temp.ks &lt;- unique(tab.stations$Broadcast_Species[tab.stations$Station==stationIDs[jj]])
  if(length(temp.ks)==1){
    print(paste0(&quot;Station &quot;, stationIDs[jj], &quot; had broadcast species &quot;, temp.ks))
  }else{
    print(paste0(&quot;Station &quot;, stationIDs[jj], &quot; has &gt;1 broadcast species listed:&quot;, temp.ks))
  }
}
</code></pre>

<pre><code>## [1] &quot;Station EI1.1 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station EI1.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station EI1.3 had broadcast species Crested Owl&quot;
## [1] &quot;Station EI1.4 had broadcast species Black and White Owl&quot;
## [1] &quot;Station EI1.5 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station EI1.6 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station EI1.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station EI1.8 had broadcast species Crested Owl&quot;
## [1] &quot;Station EI1.9 had broadcast species Black and White Owl&quot;
## [1] &quot;Station EI1.10 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station EI2.1 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station EI2.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station EI2.3 had broadcast species Crested Owl&quot;
## [1] &quot;Station EI2.4 had broadcast species Black and White Owl&quot;
## [1] &quot;Station EI2.5 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station EI2.6 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station EI2.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station EI2.8 had broadcast species Crested Owl&quot;
## [1] &quot;Station EI2.9 had broadcast species Black and White Owl&quot;
## [1] &quot;Station EI2.10 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station N1.1 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station N1.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station N1.3 had broadcast species Crested Owl&quot;
## [1] &quot;Station N1.4 had broadcast species Black and White Owl&quot;
## [1] &quot;Station N1.5 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station N1.6 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station N1.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station N1.8 had broadcast species Crested Owl&quot;
## [1] &quot;Station N1.9 had broadcast species Black and White Owl&quot;
## [1] &quot;Station N1.10 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station N2.1 had broadcast species Pacific Screech Owl&quot;
## [1] &quot;Station N2.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station N2.3 had broadcast species Crested Owl&quot;
## [1] &quot;Station N2.4 had broadcast species Black and White Owl&quot;
## [1] &quot;Station N2.5 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station N2.6 has &gt;1 broadcast species listed:Pacific Screech Owl&quot;
## [2] &quot;Station N2.6 has &gt;1 broadcast species listed:NA&quot;                 
## [1] &quot;Station N2.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station N2.8 has &gt;1 broadcast species listed:Crested Owl&quot;
## [2] &quot;Station N2.8 has &gt;1 broadcast species listed:NA&quot;         
## [1] &quot;Station N2.9 has &gt;1 broadcast species listed:Black and White Owl&quot;
## [2] &quot;Station N2.9 has &gt;1 broadcast species listed:NA&quot;                 
## [1] &quot;Station N2.10 had broadcast species Spectacled Owl&quot;
## [1] &quot;Station M2.1 had broadcast species Whiskered Screech Owl&quot;
## [1] &quot;Station M2.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station M2.3 had broadcast species Guat. Barred Owl&quot;
## [1] &quot;Station M2.4 had broadcast species Stygian Owl&quot;
## [1] &quot;Station M2.5 had broadcast species Great Horned Owl&quot;
## [1] &quot;Station M2.6 had broadcast species Whiskered Screech Owl&quot;
## [1] &quot;Station M2.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station M2.8 had broadcast species Guat. Barred Owl&quot;
## [1] &quot;Station M2.9 had broadcast species Stygian Owl&quot;
## [1] &quot;Station M2.10 had broadcast species Great Horned Owl&quot;
## [1] &quot;Station M1.1 had broadcast species Whiskered Screech Owl&quot;
## [1] &quot;Station M1.2 had broadcast species Mottled Owl&quot;
## [1] &quot;Station M1.3 had broadcast species Guat. Barred Owl&quot;
## [1] &quot;Station M1.4 had broadcast species Stygian Owl&quot;
## [1] &quot;Station M1.5 had broadcast species Great Horned Owl&quot;
## [1] &quot;Station M1.6 had broadcast species Whiskered Screech Owl&quot;
## [1] &quot;Station M1.7 had broadcast species Mottled Owl&quot;
## [1] &quot;Station M1.8 had broadcast species Guat. Barred Owl&quot;
## [1] &quot;Station M1.9 had broadcast species Stygian Owl&quot;
## [1] &quot;Station M1.10 had broadcast species Great Horned Owl&quot;
</code></pre>

<p>Stations N2.6, N2.8, and N2.9 were not surveyed on a couple occasions, 
and got values of &ldquo;NA&rdquo; for those broadcast species. </p>

<pre><code class="r">surveys.NAs &lt;- tab.stations$Survey_ID[is.na(tab.stations$Broadcast_Species)]
(stations.NAs &lt;- tab.stations$Station[is.na(tab.stations$Broadcast_Species)])
</code></pre>

<pre><code>## [1] &quot;N2.8&quot; &quot;N2.9&quot; &quot;N2.6&quot;
</code></pre>

<pre><code class="r"># Note: These stations will need to be replaced with NAs in the Ys below, NOT ZEROS
</code></pre>

<p>Now, replace NAs with &ldquo;correct&rdquo; broadcast species for covariate purposes</p>

<pre><code class="r">for(xx in 1:length(stations.NAs)){
  owlnames &lt;- tab.stations$Broadcast_Species[tab.stations$Station %in% stations.NAs[xx]]
  temp.k &lt;- unique(owlnames[!is.na(owlnames)])
  tab.stations$Broadcast_Species[tab.stations$Station %in% stations.NAs[xx]] &lt;- temp.k
}
unique(tab.stations$Broadcast_Species[tab.stations$Station %in% stations.NAs])
</code></pre>

<pre><code>## [1] &quot;Pacific Screech Owl&quot; &quot;Crested Owl&quot;         &quot;Black and White Owl&quot;
</code></pre>

<p>Create matrices for covariate of broadcast species (shared intercept)</p>

<pre><code class="r">(route.Names &lt;- unique(tab.route$Route_ID))
</code></pre>

<pre><code>## [1] &quot;EI1&quot; &quot;EI2&quot; &quot;M1&quot;  &quot;M2&quot;  &quot;N1&quot;  &quot;N2&quot;
</code></pre>

<pre><code class="r">(broadcast.species &lt;- unique(tab.stations$Broadcast_Species))
</code></pre>

<pre><code>## [1] &quot;Pacific Screech Owl&quot;   &quot;Mottled Owl&quot;           &quot;Crested Owl&quot;          
## [4] &quot;Black and White Owl&quot;   &quot;Spectacled Owl&quot;        &quot;Whiskered Screech Owl&quot;
## [7] &quot;Guat. Barred Owl&quot;      &quot;Stygian Owl&quot;           &quot;Great Horned Owl&quot;
</code></pre>

<pre><code class="r">(broadcast.species.index &lt;- 1:length(broadcast.species))
</code></pre>

<pre><code>## [1] 1 2 3 4 5 6 7 8 9
</code></pre>

<pre><code class="r">ks.index.numb &lt;- ks
for(hh in 1:length(route.Names)){

  for(ht in 1:length(grep(pattern = route.Names[hh], names(ks)))){

    for(jj in 1:10){ # across all 10 stations per route

      # Find all the tables in the ks list with correct Route and fill in intercept
      ks[[grep(pattern = route.Names[hh], names(ks))[ht]]][jj,1] &lt;- 0 #intercept pre-broadcast
      ks.index.numb[[grep(pattern = route.Names[hh], 
                          names(ks.index.numb))[ht]]][jj,1] &lt;- 0 #intercept pre-broadcast

      # Find all the tables in the ks list with correct Route and fill in intercept
      ks[[grep(pattern = route.Names[hh], names(ks))[ht]]][jj,2] &lt;- unique(
        tab.stations$Broadcast_Species[tab.stations$Station == paste0(route.Names[hh],&quot;.&quot;,jj)]
      )
      ks.index.numb[[grep(pattern = route.Names[hh], names(ks))[ht]]][jj,2] &lt;- 
        broadcast.species.index[broadcast.species == ks[[grep(pattern = route.Names[hh], names(ks))[ht]]][jj,2]]

    }

  }

}
</code></pre>

<h2>Prepare support data for saving</h2>

<hr/>

<h2>Define variables</h2>

<p>Observations</p>

<pre><code class="r">n.route &lt;- length(unique(data.jags$Route_ID)) # hh
route.names &lt;- unique(data.jags$Route_ID)

n.year &lt;- length(min(data.jags$year):max(data.jags$year)) # tt
year.names &lt;- min(data.jags$year):max(data.jags$year)

n.survey &lt;- max(data.jags$order) # ii
n.station &lt;- 10 # jj
n.broadcast &lt;- 2 # kk
</code></pre>

<p>Create a lookup table to link the route.year.survey 
dataset of Ys with a numerical index 1:198</p>

<pre><code class="r">lookup.hhttii.names &lt;- names(ys)
lookup.hhttii.numb &lt;- 1:length(lookup.hhttii.names)
lookup.hhttii.array &lt;- array(NA, dim = c(n.route, n.year, n.survey))

for(ii in 1:n.survey){
  for(hh in 1:n.route){
    for(tt in 1:n.year){

      temp.record &lt;- 
        lookup.hhttii.numb[
          lookup.hhttii.names == paste0(route.names[hh],&quot;.&quot;,year.names[tt],&quot;.&quot;,ii)]

      lookup.hhttii.array[hh,tt,ii] &lt;- temp.record

    }
  }
}
lookup.hhttii.array
</code></pre>

<pre><code>## , , 1
## 
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
## [1,]    1    4    7   10   13   16   19   22   25    28    31
## [2,]   34   37   40   43   46   49   52   55   58    61    64
## [3,]   67   70   73   76   79   82   85   88   91    94    97
## [4,]  100  103  106  109  112  115  118  121  124   127   130
## [5,]  133  136  139  142  145  148  151  154  157   160   163
## [6,]  166  169  172  175  178  181  184  187  190   193   196
## 
## , , 2
## 
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
## [1,]    2    5    8   11   14   17   20   23   26    29    32
## [2,]   35   38   41   44   47   50   53   56   59    62    65
## [3,]   68   71   74   77   80   83   86   89   92    95    98
## [4,]  101  104  107  110  113  116  119  122  125   128   131
## [5,]  134  137  140  143  146  149  152  155  158   161   164
## [6,]  167  170  173  176  179  182  185  188  191   194   197
## 
## , , 3
## 
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
## [1,]    3    6    9   12   15   18   21   24   27    30    33
## [2,]   36   39   42   45   48   51   54   57   60    63    66
## [3,]   69   72   75   78   81   84   87   90   93    96    99
## [4,]  102  105  108  111  114  117  120  123  126   129   132
## [5,]  135  138  141  144  147  150  153  156  159   162   165
## [6,]  168  171  174  177  180  183  186  189  192   195   198
</code></pre>

<p>Turn ks into arrays</p>

<pre><code class="r">ks.array &lt;- array(unlist(ks), dim = c(10, 2, length(lookup.hhttii.names)))
ks.array.index &lt;- array(as.numeric(unlist(ks.index.numb)), 
                        dim = c(10, 2, length(lookup.hhttii.names)))
</code></pre>

<p>Convert ks into a series of 10 model matrices</p>

<p>For example means parameterization, w/ 1s for Pacific screech owl in one matrix, etc</p>

<p>Pre-broadcast</p>

<pre><code class="r">ks.prebroad &lt;- array(as.numeric(rep(c(1,0), each = 10)), 
                     dim = c(10,2, length(lookup.hhttii.names)))
ks.prebroad[,,1]
</code></pre>

<pre><code>##       [,1] [,2]
##  [1,]    1    0
##  [2,]    1    0
##  [3,]    1    0
##  [4,]    1    0
##  [5,]    1    0
##  [6,]    1    0
##  [7,]    1    0
##  [8,]    1    0
##  [9,]    1    0
## [10,]    1    0
</code></pre>

<pre><code class="r">ks.pacific.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Pacific Screech Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.pacific &lt;- array(as.numeric(unlist(ks.pacific.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))

ks.mottled.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Mottled Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.mottled &lt;- array(as.numeric(unlist(ks.mottled.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))

ks.crested.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Crested Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.crested &lt;- array(as.numeric(unlist(ks.crested.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))

ks.bw.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Black and White Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.bw &lt;- array(as.numeric(unlist(ks.bw.list)), 
               dim = c(10, 2, length(lookup.hhttii.names)))

ks.spectacled.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Spectacled Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.spectacled &lt;- array(as.numeric(unlist(ks.spectacled.list)), 
                       dim = c(10, 2, length(lookup.hhttii.names)))

ks.whiskered.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Whiskered&quot;, 1, 0), how = &quot;replace&quot;)
ks.whiskered &lt;- array(as.numeric(unlist(ks.whiskered.list)), 
                      dim = c(10, 2, length(lookup.hhttii.names)))

ks.gbarred.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Guat. Barred Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.gbarred &lt;- array(as.numeric(unlist(ks.gbarred.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))

ks.stygian.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Stygian Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.stygian &lt;- array(as.numeric(unlist(ks.stygian.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))

ks.ghorned.list &lt;- 
  rapply(ks, function(x) ifelse(x == &quot;Great Horned Owl&quot;, 1, 0), how = &quot;replace&quot;)
ks.ghorned &lt;- array(as.numeric(unlist(ks.ghorned.list)), 
                    dim = c(10, 2, length(lookup.hhttii.names)))
</code></pre>

<p>All levels of k</p>

<pre><code class="r">k.names &lt;- unique(as.character(ks.array[,2,]))
ks.levels &lt;- c(0, 1:length(k.names)) # 0 if pre-broadcast, 1:9 if post-broadcast
</code></pre>

<hr/>

<h2>Process by species of owl</h2>

<pre><code class="r">columns.to.keep &lt;- c(&quot;Owl_ID&quot;, &quot;Stations_ID&quot;, &quot;Owl_Species_ID&quot;, 
                     &quot;Owl_Number&quot;, &quot;Minute_1&quot;, &quot;Minute_2&quot;, &quot;Minute_6-12&quot;)
</code></pre>

<h3>Mottled Owl</h3>

<p>Duplicate data set up</p>

<pre><code class="r">mottd.ys &lt;- ys
</code></pre>

<p>Separate out only Mottled Owls data and join with stations table</p>

<pre><code class="r">tab.owls.mottd &lt;- tab.owls[tab.owls$Owl_Species_ID==&quot;Mottd&quot;,columns.to.keep]
mottd.master &lt;- left_join(x = tab.owls.mottd, y = tab.stations, by = &quot;Stations_ID&quot;)
</code></pre>

<p>Process observations for each station and survey night and survey period</p>

<p>Create for-loop to convert owl observations into binary data</p>

<pre><code class="r">for(hh in 1:length(route.Names)){ # across routes
  for(tt in 1:length(min(tab.survey$year):max(tab.survey$year))){ # across years
    for(ii in 1:max(tab.survey$order)){ # across surveys per year

      temp.route &lt;- route.Names[hh]
      temp.year &lt;- c(min(tab.survey$year):max(tab.survey$year))[tt]
      temp.survey &lt;- ii
      temp.survey_ID &lt;- tab.survey$Survey_ID[tab.survey$Route_ID == temp.route &amp;
                                               tab.survey$year == temp.year &amp;
                                               tab.survey$order == ii]
      survey.notexist.test &lt;- length(temp.survey_ID) == 0
      if(survey.notexist.test == FALSE){
        for(jj in 1:10){ # across stations
          owls_observed &lt;- mottd.master[mottd.master$Survey_ID==temp.survey_ID &amp;
                                          mottd.master$Station == paste0(temp.route,&quot;.&quot;,jj),]


          # Was observation before or after broadcast?
          # kk = 1 for before broadcast
          # kk = 2 for after broadcast
          logic.prebroadcast &lt;- c(owls_observed$Minute_1, owls_observed$Minute_2)
          logic.postbroadcast &lt;- c(owls_observed$`Minute_6-12`)

          mottd.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,1] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.prebroadcast&gt;0), yes = 1, no = 0)
          mottd.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,2] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.postbroadcast&gt;0), yes = 1, no = 0)
        }

      }



    }
  }
}
</code></pre>

<p>Verify that it looks correct: </p>

<pre><code class="r">mottd.ys[[1]]
</code></pre>

<pre><code>##       [,1] [,2]
##  [1,]    0    0
##  [2,]    0    1
##  [3,]    0    0
##  [4,]    0    1
##  [5,]    1    0
##  [6,]    1    1
##  [7,]    1    0
##  [8,]    1    1
##  [9,]    1    1
## [10,]    1    0
</code></pre>

<pre><code class="r">mottd.master[mottd.master$Survey_ID==20,1:9]
</code></pre>

<pre><code>## # A tibble: 16 x 9
##    Owl_ID Stations_ID Owl_Species_ID Owl_Number Minute_1 Minute_2 `Minute_6-12` Survey_ID
##     &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;    &lt;lgl&gt;    &lt;lgl&gt;             &lt;dbl&gt;
##  1    142          93 Mottd                   1 FALSE    FALSE    TRUE                 20
##  2    143          93 Mottd                   2 FALSE    FALSE    TRUE                 20
##  3    144          95 Mottd                   1 FALSE    FALSE    TRUE                 20
##  4    145          95 Mottd                   2 FALSE    FALSE    TRUE                 20
##  5    146          96 Mottd                   1 TRUE     FALSE    FALSE                20
##  6    152          98 Mottd                   1 TRUE     FALSE    FALSE                20
##  7    157         100 Mottd                   1 FALSE    TRUE     TRUE                 20
##  8    158         100 Mottd                   2 FALSE    FALSE    TRUE                 20
##  9    159         100 Mottd                   3 FALSE    FALSE    TRUE                 20
## 10    161         101 Mottd                   1 FALSE    TRUE     FALSE                20
## 11   1134          97 Mottd                   1 TRUE     TRUE     TRUE                 20
## 12   1135          97 Mottd                   2 FALSE    FALSE    TRUE                 20
## 13   1138         903 Mottd                   1 FALSE    TRUE     TRUE                 20
## 14   1139         903 Mottd                   2 FALSE    TRUE     FALSE                20
## 15   1140         903 Mottd                   3 FALSE    FALSE    TRUE                 20
## 16   1141         903 Mottd                   4 FALSE    FALSE    TRUE                 20
## # … with 1 more variable: Station &lt;chr&gt;
</code></pre>

<h3>FerPy</h3>

<p>Duplicate data set up</p>

<pre><code class="r">ferpy.ys &lt;- ys
</code></pre>

<p>Separate out only FerPy Owls data and join with stations table</p>

<pre><code class="r">tab.owls.ferpy &lt;- tab.owls[tab.owls$Owl_Species_ID==&quot;FerPy&quot;,columns.to.keep]
ferpy.master &lt;- left_join(x = tab.owls.ferpy, y = tab.stations, by = &quot;Stations_ID&quot;)
</code></pre>

<p>Process observations for each station and survey night and survey period</p>

<p>Create for-loop to convert owl observations into binary data</p>

<pre><code class="r">for(hh in 1:length(route.Names)){ # across routes
  for(tt in 1:length(min(tab.survey$year):max(tab.survey$year))){ # across years
    for(ii in 1:max(tab.survey$order)){ # across surveys per year

      temp.route &lt;- route.Names[hh]
      temp.year &lt;- c(min(tab.survey$year):max(tab.survey$year))[tt]
      temp.survey &lt;- ii
      temp.survey_ID &lt;- tab.survey$Survey_ID[tab.survey$Route_ID == temp.route &amp;
                                               tab.survey$year == temp.year &amp;
                                               tab.survey$order == ii]
      survey.notexist.test &lt;- length(temp.survey_ID) == 0
      if(survey.notexist.test == FALSE){
        for(jj in 1:10){ # across stations
          owls_observed &lt;- ferpy.master[ferpy.master$Survey_ID==temp.survey_ID &amp;
                                          ferpy.master$Station == paste0(temp.route,&quot;.&quot;,jj),]


          # Was observation before or after broadcast?
          # kk = 1 for before broadcast
          # kk = 2 for after broadcast
          logic.prebroadcast &lt;- c(owls_observed$Minute_1, owls_observed$Minute_2)
          logic.postbroadcast &lt;- c(owls_observed$`Minute_6-12`)

          ferpy.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,1] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.prebroadcast&gt;0), yes = 1, no = 0)
          ferpy.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,2] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.postbroadcast&gt;0), yes = 1, no = 0)
        }

      }



    }
  }
}
</code></pre>

<p>Verify that it looks correct: </p>

<pre><code class="r">ferpy.ys[[1]]
</code></pre>

<pre><code>##       [,1] [,2]
##  [1,]    1    1
##  [2,]    0    0
##  [3,]    0    0
##  [4,]    0    0
##  [5,]    0    0
##  [6,]    0    0
##  [7,]    0    0
##  [8,]    0    0
##  [9,]    0    0
## [10,]    0    0
</code></pre>

<pre><code class="r">ferpy.master[ferpy.master$Survey_ID==20,1:9]
</code></pre>

<pre><code>## # A tibble: 2 x 9
##   Owl_ID Stations_ID Owl_Species_ID Owl_Number Minute_1 Minute_2 `Minute_6-12` Survey_ID Station
##    &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;    &lt;lgl&gt;    &lt;lgl&gt;             &lt;dbl&gt; &lt;chr&gt;  
## 1    140          92 FerPy                   1 TRUE     FALSE    TRUE                 20 EI1.1  
## 2    141          92 FerPy                   2 FALSE    FALSE    TRUE                 20 EI1.1
</code></pre>

<h3>Specd</h3>

<p>Duplicate data set up</p>

<pre><code class="r">specd.ys &lt;- ys
</code></pre>

<p>Separate out only Specd Owls data and join with stations table</p>

<pre><code class="r">tab.owls.specd &lt;- tab.owls[tab.owls$Owl_Species_ID==&quot;Specd&quot;,columns.to.keep]
specd.master &lt;- left_join(x = tab.owls.specd, y = tab.stations, by = &quot;Stations_ID&quot;)
</code></pre>

<p>Process observations for each station and survey night and survey period</p>

<p>Create for-loop to convert owl observations into binary data</p>

<pre><code class="r">for(hh in 1:length(route.Names)){ # across routes
  for(tt in 1:length(min(tab.survey$year):max(tab.survey$year))){ # across years
    for(ii in 1:max(tab.survey$order)){ # across surveys per year

      temp.route &lt;- route.Names[hh]
      temp.year &lt;- c(min(tab.survey$year):max(tab.survey$year))[tt]
      temp.survey &lt;- ii
      temp.survey_ID &lt;- tab.survey$Survey_ID[tab.survey$Route_ID == temp.route &amp;
                                               tab.survey$year == temp.year &amp;
                                               tab.survey$order == ii]
      survey.notexist.test &lt;- length(temp.survey_ID) == 0
      if(survey.notexist.test == FALSE){
        for(jj in 1:10){ # across stations
          owls_observed &lt;- specd.master[specd.master$Survey_ID==temp.survey_ID &amp;
                                          specd.master$Station == paste0(temp.route,&quot;.&quot;,jj),]


          # Was observation before or after broadcast?
          # kk = 1 for before broadcast
          # kk = 2 for after broadcast
          logic.prebroadcast &lt;- c(owls_observed$Minute_1, owls_observed$Minute_2)
          logic.postbroadcast &lt;- c(owls_observed$`Minute_6-12`)

          specd.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,1] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.prebroadcast&gt;0), yes = 1, no = 0)
          specd.ys[[paste0(temp.route,&quot;.&quot;,temp.year,&quot;.&quot;,temp.survey)]][jj,2] &lt;- #look up rt.year.survey 
            ifelse(sum(logic.postbroadcast&gt;0), yes = 1, no = 0)
        }

      }



    }
  }
}
</code></pre>

<p>Verify that it looks correct: </p>

<pre><code class="r">specd.ys$N1.2004.1
</code></pre>

<pre><code>##       [,1] [,2]
##  [1,]    0    1
##  [2,]    0    1
##  [3,]    0    0
##  [4,]    0    0
##  [5,]    0    0
##  [6,]    0    0
##  [7,]    0    0
##  [8,]    0    1
##  [9,]    1    1
## [10,]    1    1
</code></pre>

<pre><code class="r">specd.master[specd.master$Survey_ID==16,1:9]
</code></pre>

<pre><code>## # A tibble: 12 x 9
##    Owl_ID Stations_ID Owl_Species_ID Owl_Number Minute_1 Minute_2 `Minute_6-12` Survey_ID
##     &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;    &lt;lgl&gt;    &lt;lgl&gt;             &lt;dbl&gt;
##  1     84          52 Specd                   1 FALSE    FALSE    TRUE                 16
##  2     88          59 Specd                   2 FALSE    FALSE    TRUE                 16
##  3     89          59 Specd                   3 FALSE    FALSE    TRUE                 16
##  4     91          60 Specd                   2 TRUE     TRUE     TRUE                 16
##  5     92          60 Specd                   3 TRUE     TRUE     TRUE                 16
##  6     93          60 Specd                   4 TRUE     TRUE     TRUE                 16
##  7     94          61 Specd                   1 FALSE    TRUE     TRUE                 16
##  8     95          61 Specd                   2 FALSE    TRUE     TRUE                 16
##  9     96          61 Specd                   3 FALSE    TRUE     TRUE                 16
## 10     97          61 Specd                   4 FALSE    TRUE     TRUE                 16
## 11     98          61 Specd                   5 FALSE    TRUE     TRUE                 16
## 12   1127          53 Specd                   1 FALSE    FALSE    TRUE                 16
## # … with 1 more variable: Station &lt;chr&gt;
</code></pre>

<hr/>

<h2>Save files</h2>

<p>Processed Owl Data</p>

<pre><code class="r">save(data.jags, mottd.ys, ferpy.ys, specd.ys,
     file = &quot;data/processed_data/owl_data.Rdata&quot;)
</code></pre>

<p>Processed Support data</p>

<pre><code class="r">save(
  lookup.hhttii.names, lookup.hhttii.array,
  ks, ks.index.numb, ks.array.index, 
  k.names, ks.levels, 
  ks.prebroad, ks.pacific, ks.mottled, ks.crested, ks.bw, ks.spectacled, 
  ks.whiskered, ks.gbarred, ks.stygian, ks.ghorned,
  file = &quot;data/processed_data/ks_jags_input.Rdata&quot;)
</code></pre>

<p>Complete list of surveys conducted by year and route</p>

<pre><code class="r">save(survey_list, file = &quot;data/processed_data/survey_list.Rdata&quot;)
</code></pre>

<hr/>

<h3>Footer</h3>

<p>Session Info</p>

<pre><code class="r">devtools::session_info()
</code></pre>

<pre><code>## ─ Session info ───────────────────────────────────────────────────────────────────────────────
##  setting  value                       
##  version  R version 4.0.2 (2020-06-22)
##  os       macOS Mojave 10.14.6        
##  system   x86_64, darwin17.0          
##  ui       RStudio                     
##  language (EN)                        
##  collate  en_US.UTF-8                 
##  ctype    en_US.UTF-8                 
##  tz       America/Chicago             
##  date     2020-10-15                  
## 
## ─ Packages ───────────────────────────────────────────────────────────────────────────────────
##  package      * version date       lib source        
##  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.2)
##  backports      1.1.8   2020-06-17 [1] CRAN (R 4.0.2)
##  base64enc      0.1-3   2015-07-28 [1] CRAN (R 4.0.2)
##  callr          3.4.3   2020-03-28 [1] CRAN (R 4.0.2)
##  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.2)
##  checkmate      2.0.0   2020-02-06 [1] CRAN (R 4.0.2)
##  chron        * 2.3-56  2020-08-18 [1] CRAN (R 4.0.2)
##  cli            2.0.2   2020-02-28 [1] CRAN (R 4.0.2)
##  cluster        2.1.0   2019-06-19 [1] CRAN (R 4.0.2)
##  colorspace     1.4-1   2019-03-18 [1] CRAN (R 4.0.2)
##  crayon         1.3.4   2017-09-16 [1] CRAN (R 4.0.2)
##  data.table     1.13.0  2020-07-24 [1] CRAN (R 4.0.2)
##  desc           1.2.0   2018-05-01 [1] CRAN (R 4.0.2)
##  devtools     * 2.3.1   2020-07-21 [1] CRAN (R 4.0.2)
##  digest         0.6.25  2020-02-23 [1] CRAN (R 4.0.2)
##  dplyr        * 1.0.1   2020-07-31 [1] CRAN (R 4.0.2)
##  ellipsis       0.3.1   2020-05-15 [1] CRAN (R 4.0.2)
##  evaluate       0.14    2019-05-28 [1] CRAN (R 4.0.1)
##  ezknitr      * 0.6     2016-09-16 [1] CRAN (R 4.0.2)
##  fansi          0.4.1   2020-01-08 [1] CRAN (R 4.0.2)
##  forcats        0.5.0   2020-03-01 [1] CRAN (R 4.0.2)
##  foreign        0.8-80  2020-05-24 [1] CRAN (R 4.0.2)
##  Formula      * 1.2-3   2018-05-03 [1] CRAN (R 4.0.2)
##  fs             1.5.0   2020-07-31 [1] CRAN (R 4.0.2)
##  gdata        * 2.18.0  2017-06-06 [1] CRAN (R 4.0.2)
##  generics       0.0.2   2018-11-29 [1] CRAN (R 4.0.2)
##  ggplot2      * 3.3.2   2020-06-19 [1] CRAN (R 4.0.2)
##  glue           1.4.1   2020-05-13 [1] CRAN (R 4.0.2)
##  gridExtra      2.3     2017-09-09 [1] CRAN (R 4.0.2)
##  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.2)
##  gtools         3.8.2   2020-03-31 [1] CRAN (R 4.0.2)
##  haven          2.3.1   2020-06-01 [1] CRAN (R 4.0.2)
##  highr          0.8     2019-03-20 [1] CRAN (R 4.0.2)
##  Hmisc        * 4.4-1   2020-08-10 [1] CRAN (R 4.0.2)
##  hms            0.5.3   2020-01-08 [1] CRAN (R 4.0.2)
##  htmlTable      2.0.1   2020-07-05 [1] CRAN (R 4.0.2)
##  htmltools      0.5.0   2020-06-16 [1] CRAN (R 4.0.2)
##  htmlwidgets    1.5.1   2019-10-08 [1] CRAN (R 4.0.2)
##  ImportExport * 1.1     2015-09-19 [1] CRAN (R 4.0.2)
##  jpeg           0.1-8.1 2019-10-24 [1] CRAN (R 4.0.2)
##  knitr        * 1.29    2020-06-23 [1] CRAN (R 4.0.2)
##  lattice      * 0.20-41 2020-04-02 [1] CRAN (R 4.0.2)
##  latticeExtra   0.6-29  2019-12-19 [1] CRAN (R 4.0.2)
##  lifecycle      0.2.0   2020-03-06 [1] CRAN (R 4.0.2)
##  lubridate    * 1.7.9   2020-06-08 [1] CRAN (R 4.0.2)
##  magrittr       1.5     2014-11-22 [1] CRAN (R 4.0.2)
##  Matrix         1.2-18  2019-11-27 [1] CRAN (R 4.0.2)
##  memoise        1.1.0   2017-04-21 [1] CRAN (R 4.0.2)
##  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.2)
##  nnet           7.3-14  2020-04-26 [1] CRAN (R 4.0.2)
##  pillar         1.4.6   2020-07-10 [1] CRAN (R 4.0.2)
##  pkgbuild       1.1.0   2020-07-13 [1] CRAN (R 4.0.2)
##  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.2)
##  pkgload        1.1.0   2020-05-29 [1] CRAN (R 4.0.2)
##  png            0.1-7   2013-12-03 [1] CRAN (R 4.0.2)
##  prettyunits    1.1.1   2020-01-24 [1] CRAN (R 4.0.2)
##  processx       3.4.3   2020-07-05 [1] CRAN (R 4.0.2)
##  ps             1.3.3   2020-05-08 [1] CRAN (R 4.0.2)
##  purrr          0.3.4   2020-04-17 [1] CRAN (R 4.0.2)
##  R.methodsS3    1.8.0   2020-02-14 [1] CRAN (R 4.0.2)
##  R.oo           1.23.0  2019-11-03 [1] CRAN (R 4.0.2)
##  R.utils        2.9.2   2019-12-08 [1] CRAN (R 4.0.2)
##  R6             2.4.1   2019-11-12 [1] CRAN (R 4.0.2)
##  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 4.0.2)
##  Rcpp           1.0.5   2020-07-06 [1] CRAN (R 4.0.2)
##  readxl       * 1.3.1   2019-03-13 [1] CRAN (R 4.0.2)
##  remotes        2.2.0   2020-07-21 [1] CRAN (R 4.0.2)
##  rJava          0.9-13  2020-07-06 [1] CRAN (R 4.0.2)
##  rlang          0.4.7   2020-07-09 [1] CRAN (R 4.0.2)
##  RODBC        * 1.3-17  2020-05-11 [1] CRAN (R 4.0.2)
##  rpart          4.1-15  2019-04-12 [1] CRAN (R 4.0.2)
##  rprojroot      1.3-2   2018-01-03 [1] CRAN (R 4.0.2)
##  rstudioapi     0.11    2020-02-07 [1] CRAN (R 4.0.2)
##  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.2)
##  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.2)
##  stringi        1.4.6   2020-02-17 [1] CRAN (R 4.0.2)
##  stringr        1.4.0   2019-02-10 [1] CRAN (R 4.0.2)
##  survival     * 3.1-12  2020-04-10 [1] CRAN (R 4.0.2)
##  testthat       2.3.2   2020-03-02 [1] CRAN (R 4.0.2)
##  tibble         3.0.3   2020-07-10 [1] CRAN (R 4.0.2)
##  tidyselect     1.1.0   2020-05-11 [1] CRAN (R 4.0.2)
##  usethis      * 1.6.1   2020-04-29 [1] CRAN (R 4.0.2)
##  utf8           1.1.4   2018-05-24 [1] CRAN (R 4.0.2)
##  vctrs          0.3.2   2020-07-15 [1] CRAN (R 4.0.2)
##  withr          2.2.0   2020-04-20 [1] CRAN (R 4.0.2)
##  xfun           0.16    2020-07-24 [1] CRAN (R 4.0.2)
##  xlsx         * 0.6.4.2 2020-09-12 [1] CRAN (R 4.0.2)
##  xlsxjars       0.6.1   2014-08-22 [1] CRAN (R 4.0.2)
## 
## [1] /Library/Frameworks/R.framework/Versions/4.0/Resources/library
</code></pre>

<p>This document was &ldquo;spun&rdquo; with:</p>

<p>ezspin(file = &ldquo;programs/a_process_data.R&rdquo;, out_dir = &ldquo;output&rdquo;, fig_dir = &ldquo;figures&rdquo;, keep_md = F)</p>

</body>

</html>
